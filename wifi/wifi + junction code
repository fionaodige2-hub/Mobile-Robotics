// ================== WIFI + STATE-BASED LINE FOLLOWER (0→1→2→3→4→5) ==================
#include <WiFi.h>

// -------- WiFi details --------
const char* ssid     = "iot";
const char* password = "overtechnicality7petrophilous";

// Test server details
const char* SERVER_HOST = "3.250.38.184";
const uint16_t SERVER_PORT = 8000;

WiFiClient client;

// ================== MOTOR PINS ==================
int motor1PWM   = 37;   // AENABLE
int motor1Phase = 38;   // APHASE

int motor2PWM   = 39;   // BENABLE
int motor2Phase = 20;   // BPHASE

// ================== LINE SENSORS & CONTROL ==================
int AnalogValue[5] = {0,0,0,0,0};
int AnalogPin[5]   = {4,5,6,7,15};   // keeping 8 free for music 

int THRESH = 1500;  // <-- CALIBRATE FOR YOUR TRACK

int BASE_L = 200;
int BASE_R = 200;
int KP     = 60;

// Median filter buffers (last 5 samples per sensor)
int buf[5][5] = {0};
int bufIdx = 0;

int median5(int a, int b, int c, int d, int e) {
  int x[5] = {a,b,c,d,e};
  for (int i=0;i<5;i++){
    for (int j=i+1;j<5;j++){
      if (x[j] < x[i]) { int t=x[i]; x[i]=x[j]; x[j]=t; }
    }
  }
  return x[2];
}

// -------------------- STATE MACHINE --------------------
enum RobotState {
  FOLLOW_LINE,
  TURNING_LEFT
};

RobotState state = FOLLOW_LINE;
unsigned long turnStartMs = 0;

// -------------------- ROUTING / POSITIONS --------------------
int  currentPosition      = 0;   // start at junction 0
int  lastSentPosition     = -1;  // last position reported to server
bool prevAtJunction       = false;
int  junctionStableCount  = 0;
const int MIN_JUNCTION_SAMPLES = 3;  // how many loops pattern must persist

// ================== WIFI HELPERS ==================
void connectToWiFi() {
  Serial.print("Connecting to network: ");
  Serial.print(ssid);
  Serial.flush();

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    Serial.flush();
    delay(300);
  }
  Serial.println(" Connected");
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());
}

void ensureWiFiConnected() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi dropped, reconnecting...");
    connectToWiFi();
  }
}

void sendPositionToServer(int pos) {
  ensureWiFiConnected();

  Serial.print("Connecting to server ");
  Serial.print(SERVER_HOST);
  Serial.print(":");
  Serial.println(SERVER_PORT);

  if (!client.connect(SERVER_HOST, SERVER_PORT)) {
    Serial.println("Connection to server failed");
    return;
  }

  String msg = String(pos) + "\n";  // "0\n", "1\n", ...
  client.print(msg);
  client.flush();

  Serial.print("Sent to server: ");
  Serial.println(msg);

  client.stop();
}

// ================== MOTOR FUNCTIONS ==================
void GoForward(int time,int speed1,int speed2)
{
  digitalWrite(motor1Phase, HIGH);
  digitalWrite(motor2Phase, HIGH);
  analogWrite(motor1PWM, speed1);
  analogWrite(motor2PWM, speed2);
  if (time > 0) delay(time);
}

void GoBackward(int time,int speed1,int speed2)
{
  digitalWrite(motor1Phase, LOW);
  digitalWrite(motor2Phase, LOW);
  analogWrite(motor1PWM, speed1);
  analogWrite(motor2PWM, speed2);
  if (time > 0) delay(time);
}

void GoStop(int time)
{
  analogWrite(motor1PWM, 0);
  analogWrite(motor2PWM, 0);
  delay(time);
}

// ================== SETUP ==================
void setup()
{
  Serial.begin(9600);

  pinMode(motor1PWM, OUTPUT);
  pinMode(motor1Phase, OUTPUT);
  pinMode(motor2PWM, OUTPUT);
  pinMode(motor2Phase, OUTPUT);

  GoStop(0);           // motors off
  connectToWiFi();     // connect once

  // starting at junction 0
  currentPosition  = 0;
  sendPositionToServer(currentPosition);
  lastSentPosition = currentPosition;
}

// ================== MAIN LOOP ==================
void loop()
{
  // 1) Read sensors + median filter
  for (int i=0; i<5; i++) {
    int raw = analogRead(AnalogPin[i]);
    buf[i][bufIdx] = raw;
  }
  bufIdx = (bufIdx + 1) % 5;

  for (int i=0; i<5; i++) {
    AnalogValue[i] = median5(buf[i][0], buf[i][1], buf[i][2], buf[i][3], buf[i][4]);
  }

  int L2 = (AnalogValue[0] < THRESH) ? 1 : 0;
  int L1 = (AnalogValue[1] < THRESH) ? 1 : 0;
  int C  = (AnalogValue[2] < THRESH) ? 1 : 0;
  int R1 = (AnalogValue[3] < THRESH) ? 1 : 0;
  int R2 = (AnalogValue[4] < THRESH) ? 1 : 0;

  int seen  = L2 + L1 + C + R1 + R2;
  int error = (-2 * L2) + (-1 * L1) + (0 * C) + (1 * R1) + (2 * R2);

  if (seen > 0) error = error / seen;
  if (L2) error = -2;
  if (R2) error =  2;

  // -------- Junction detection: vertical bar under front sensors --------
  // Base pattern: centre + inner left + inner right on white
  // bool junctionPattern = (L1 && C && R1);
  bool junctionPattern = (L1 && L2 && C && R1 &&);

  // OPTIONAL stricter pattern (uncomment if your bar is wide enough)
  // bool junctionPattern = (L2 && L1 && C && R1 && R2);

  // make sure pattern is stable for a few loops
  if (junctionPattern) {
    junctionStableCount++;
  } else {
    junctionStableCount = 0;
  }

  bool atJunction = (junctionStableCount >= MIN_JUNCTION_SAMPLES);

  // ----- POSITION COUNTING: 0 → 1 → 2 → 3 → 4 → 5 -----
  if (atJunction && !prevAtJunction) {  // rising edge
    if (currentPosition < 5) {
      currentPosition++;      // 0->1->2->3->4->5
      if (currentPosition != lastSentPosition) {
        sendPositionToServer(currentPosition);
        lastSentPosition = currentPosition;
      }
    }
  }
  prevAtJunction = atJunction;

  static int lastError = 0;
  int leftSpeed  = BASE_L;
  int rightSpeed = BASE_R;

  // -------------------- STATE MACHINE LOGIC --------------------
  switch (state) {

    case FOLLOW_LINE:
    {
      int turn = (KP * error * (BASE_L + BASE_R)) / 220;
      int MAX_TURN = (BASE_L + BASE_R) / 2;
      if (turn >  MAX_TURN) turn =  MAX_TURN;
      if (turn < -MAX_TURN) turn = -MAX_TURN;

      leftSpeed  = BASE_L - turn;
      rightSpeed = BASE_R + turn;

      if (leftSpeed  < 0)   leftSpeed  = 0;
      if (rightSpeed < 0)   rightSpeed = 0;
      if (leftSpeed  > 255) leftSpeed  = 255;
      if (rightSpeed > 255) rightSpeed = 255;

      if (seen == 0) {
        if (lastError >= 0) {
          leftSpeed  = 120;
          rightSpeed = 60;
        } else {
          leftSpeed  = 60;
          rightSpeed = 120;
        }
      } else {
        lastError = error;
      }

      // enter TURNING_LEFT whenever we are on a junction
      if (atJunction) {
        state = TURNING_LEFT;
        turnStartMs = millis();
      }
    }
    break;

    case TURNING_LEFT:
    {
      leftSpeed  = 80;
      rightSpeed = 200;

      bool centreOnLineOnly = C && !(L1 || R1);
      bool timeout          = (millis() - turnStartMs) > 1200; // 1.2 s

      if (centreOnLineOnly || timeout) {
        state = FOLLOW_LINE;
        lastError = 0;
      }
    }
    break;
  }

  GoForward(0, leftSpeed, rightSpeed);
  delay(3);
}
